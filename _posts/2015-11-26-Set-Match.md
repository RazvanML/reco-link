---
layout: post
title: Set Match
tags: record-linkage set-matchs
categories: Record-Linkage
---

 <img src="{{'/static/img/recolink/tenisracket.jpg' | prepend: site.baseurl | prepend: site.url }}" 
    alt='Tennis racket' style="float:left;padding:15px;margin:10px;width:150px"   /> 
Most of the record linkage technique imagine two tables, composed of records and a set of association rules. Is this it?
Well, my software goes beyond this, exploring the relational dimension of data. This post is about matching sets of 
records associated to one data record.

<!--more-->

The structured data is always organized by a relational model, meaning that records usually points to one or more
records from different tables. There is a virtual link back, as the pointed record can be associated to the initial record.
This way, two types of relations between items can be exploited in record linkage. Considering the table ```A```
 and a table ```B``` endowed with a foreign key to ```A```, one record of ```B``` points to exactly one record in
 ```A``` and virtually one record in ```A``` can refer multiple records of ```B```.

In the context of record linkage, let us consider on one side the tables ```A``` and ```B``` from above to be linked to
 ```A'``` and ```B'```. 

The relations observed are of two types:

* *One-to-many* computes a score of a pair of two records from ```A```  and ```A'```,
 given the already computed scores between the corresponding records in ```B``` and ```B'```. 

* *Many-to-one* provides a rule of similarity computed on a pair of records in ```B``` and ```B'``` considering
the score of the referred records in ```A``` and ```A'```.

The relation is just one criterion, the records may benefit of additional comparison criteria.

The following example is used to illustrate the concept.


The two tables ```A``` and ```A'``` are defined as:

``` 
ID,Name
1,Group 1
2,Group 2
3,Group 3
4,Group 4
``` 

and

``` 
ID,Name
1,Group one
2,Second group
3,Third Group
4,Fourth Group
``` 

On purpose, no direct similarity criterion can be imagined for the two groups, assuming no Natural Language Processing is being performed and also ignoring the identical IDs used for cross check.


The two groups provided above are referred by a number of group members, defined as:

``` 
ID,GID,Col
101,1,Red
102,1,Yellow
103,1,Pink
104,2,Red
105,2,Blue
106,2,Black
207,2,White
301,3,Burgundy
302,3,Magenta
303,3,Orange
304,3,Cyan
401,4,Khaki
402,4,Green
``` 

and

``` 
ID,GID,Col
1,1,Red
2,1,Yellow
3,1,Pink
4,2,Red
5,2,Blue
6,2,White
7,2,Dark Gray
8,3,Magenta
9,3,Blue
10,3,Orange
11,3,Burgundy
12,4,Khaci
13,4,Green
``` 

In the second set of tables, ```GID``` is the reference to the respective group.


To be able to display the relational data, I used <a href="http://csv-jdbc.com/stels_csv.htm">StelsCSV JDBC driver </a>.
Simply for matching, the <a href="Relique JDBC">Relique JDBC driver</a> will suffice, but 
in this case it will not be possible to show the groups with their composing elements.

Data import is symmetric and similar to the previous examples, with the exeption of the `````` tag:

```xml
<matchdocument>
	<dbconnections local="local">
		<drivers>
			<driver>org.postgresql.Driver</driver>
			<driver>jstels.jdbc.csv.CsvDriver2</driver>
		</drivers>
		<connections>
			<connection id="testdata" url="jdbc:jstels:csv:data/rela/?separator=," dialect="generic"/>
			<connection id="local" url="jdbc:postgresql://127.1:5432/rel"
				user="postgres" password="r" dialect="pgsql" />
		</connections>
	</dbconnections>
	<entities>
		<left>
			<entity name="gr1" conn="testdata" shorttitle="name" title="name2">
				<query><![CDATA[
					select l.id,l.name, 
					  concat('<B>',name,'</B> <I>', l.id, '</I>, <small>',GROUP_CONCAT(c.col),'</small>') as name2, 
					  concat(name,' ',GROUP_CONCAT(c.col)) as alldata 
					 from groups1 l join content1 c on l.id=c.GID
					 group by  l.id,l.name
					 order by l.id
					   ]]>
				</query>
				<fields>
					<field name="ID" alias="id_gr_left" cardinality="ONE" type="char(7)" />
					<field name="name" cardinality="ONE" type="text" />
					<field name="name2" cardinality="ONE" type="text" />
					<field name="alldata" cardinality="ONE" type="text" />
				</fields>
				<keys>
					<key name="ID" />
				</keys>
			</entity>
			<entity name="content1" conn="testdata" shorttitle="col"
				title="name2">
				<query><![CDATA[
						select c.ID,c.GID,c.Col, 
							concat(c.col,' - ', c.ID,' - ', c.GID,' - ', l.name) as name2,
							concat(c.col,' ', l.name) as alldata							
						 from content1 c left join groups1 l on l.id=c.GID 
						 order by c.id
					   ]]>
				</query>
				<fields>
					<field name="ID" alias="id_content_left" cardinality="ONE"
						type="integer" />
					<field name="col" cardinality="ONE" type="text" />
					<field name="GID" cardinality="ONE" type="text" />
					<field name="name2" cardinality="ONE" type="text" />
					<field name="alldata" cardinality="ONE" type="text" />
				</fields>
				<keys>
					<key name="ID" />
				</keys>
				<fkeys>
					<fkey name="content2group" target="gr1" fields="GID" />
				</fkeys>
			</entity>
		</left>
		<right>
			<entity name="gr2" conn="testdata" shorttitle="name" title="name2">
				<query><![CDATA[
					select l.id,l.name, 
					  concat('<B>',name,'</B> <I>', l.id, '</I>, <small>',group_concat(c.col),'</small>') as name2, 
					  concat(name,' ',group_concat(c.col)) as alldata 
					 from groups2 l join content2 c on l.id=c.GID
					 group by  l.id,l.name
						 order by l.id
					   ]]>
				</query>
				<fields>
					<field name="ID" alias="id_gr_right" cardinality="ONE" type="char(7)" />
					<field name="name" cardinality="ONE" type="text" />
					<field name="name2" cardinality="ONE" type="text" />
					<field name="alldata" cardinality="ONE" type="text" />
				</fields>
				<keys>
					<key name="ID" />
				</keys>
			</entity>
			<entity name="content2" conn="testdata" shorttitle="col"
				title="name2">
				<query><![CDATA[
						select c.ID,c.GID,c.Col, 
							concat(c.col,' - <small>', c.ID,' - ', c.GID,'</small> - ', l.name) as name2,
							concat(c.col,' ', l.name) as alldata						
						 from content2 c left join groups2 l on l.id=c.GID 
						 order by c.id
					   ]]>
				</query>
				<fields>
					<field name="ID" alias="id_content_right" cardinality="ONE"
						type="integer" />
					<field name="col" cardinality="ONE" type="text" />
					<field name="name2" cardinality="ONE" type="text" />
					<field name="alldata" cardinality="ONE" type="text" />					
					<field name="GID" cardinality="ONE" type="char(7)" />
				</fields>
				<keys>
					<key name="ID" />
				</keys>
				<fkeys>
					<fkey name="content2group" target="gr2" fields="GID" />
				</fkeys>
			</entity>
		</right>
	</entities>
```



The results are quite impressive. All the groups as well as the changed colors were associated properly!

<figure>
    <img src="{{'/static/img/recolink/set1.png' | prepend: site.baseurl | prepend: site.url }}" 
    alt='Groups record linkage' />
    <figcaption>Groups record linkagel</figcaption>
</figure>


<figure>
    <img src="{{'/static/img/recolink/set2.png' | prepend: site.baseurl | prepend: site.url }}" 
    alt='Group elements record linkage' />
    <figcaption>Group elements record linkage</figcaption>
</figure>


